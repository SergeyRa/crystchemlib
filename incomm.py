# TODO: link loops using id

"""Module for handling incommensurately modulated structures

Classes
-------
Modf
    Defines modulation function

Functions
---------
harmcomp : int
    Component of modulation vector in harmonic
modv : tuple or None
    Extracts modulation vectors
readmodf : list
    Extracts modulation functions
"""

# CIF keys used
whitelist_incomm = [
    '_atom_site_displace_fourier_atom_site_label',
    '_atom_site_displace_fourier_axis',
    '_atom_site_displace_fourier_param_cos',
    '_atom_site_displace_fourier_param_sin',
    '_atom_site_displace_fourier_wave_vector_seq_id',
    '_atom_site_fourier_wave_vector_seq_id',
    '_atom_site_fourier_wave_vector_x',
    '_atom_site_fourier_wave_vector_y',
    '_atom_site_fourier_wave_vector_z',
    '_atom_site_occ_fourier_atom_site_label',
    '_atom_site_occ_fourier_param_cos',
    '_atom_site_occ_fourier_param_sin',
    '_atom_site_occ_fourier_wave_vector_seq_id',
    '_atom_site_occ_special_func_atom_site_label',
    '_atom_site_occ_special_func_crenel_c',
    '_atom_site_occ_special_func_crenel_w',
    '_cell_modulation_dimension',
    '_cell_wave_vector_seq_id',
    '_cell_wave_vector_x',
    '_cell_wave_vector_y',
    '_cell_wave_vector_z',
    '_jana_atom_site_displace_legendre_atom_site_label',
    '_jana_atom_site_displace_legendre_axis',
    '_jana_atom_site_displace_legendre_param_coeff',
    '_jana_atom_site_displace_legendre_param_order',
    '_jana_atom_site_fourier_wave_vector_q1_coeff']


class Modf:
    """Defines modulation function

    Attributes
    ----------
    form : str
        form of modulation function
    params : numpy.ndarray or list
        parameters of modulation function
    esds : numpy.ndarray
        esd of parameters

    Methods
    -------
    val : tuple
        Returns modulation function value and esd
    """

    def __init__(self, form, params=None, esds=None):
        """
        Parameters
        ----------
        form : str
            form of modulation function:
            harm - harmonic
            cren - crenel
            lege - Legendre polynomials on crenel interval
            none
        params : numpy.ndarray or list
            parameters of modulation function
        esds : numpy.ndarray
            esds of parameters
        """

        self.form = form
        self.params = params
        self.esds = esds

    def val(self, x4, zero=True):
        """Returns modulation function value

        Parameters
        ----------
        x4 : float
            phase of modulation vector
        zero : bool
            when True (default), (0.0, 0.0) is returned
            outside crenel interval and for self.form=='none',
            otherwise (None, None)

        Returns
        -------
        float
            modulation function value
        """

        na = (0.0, 0.0) if zero else (None, None)

        if self.form == 'harm':
            from numpy import sin, cos, pi

            return (
                (self.params[:, 1]*cos(2*pi*self.params[:, 0]*x4)
                 + self.params[:, 2]*sin(2*pi*self.params[:, 0]*x4)).sum(),
                ((self.esds[:, 1]*cos(2*pi*self.params[:, 0]*x4))**2
                 + (self.esds[:, 2]
                    * sin(2*pi*self.params[:, 0]*x4))**2).sum()**0.5
            )

        elif self.form == 'cren':
            from numpy import array
            x4 %= 1
            c, w = self.params
            test = array([x4-1, x4, x4+1])
            if ((c - w/2 <= test) & (test <= c + w/2)).any():
                return 1.0, 0.0
            else:
                return na

        elif self.form == 'lege':
            from numpy import array

            x4 %= 1
            c, w = self.params[1:]
            test = array([x4-1, x4, x4+1])
            if ((c - w/2 <= test) & (test <= c + w/2)).any():
                from scipy.special import legendre

                x = 2*(x4 - c)/w
                return (sum([coeff*legendre(order)(x) for order, coeff in
                             self.params[0][:]]),
                        sum([(esd*legendre(order)(x))**2 for order, esd in
                             zip(self.params[0][:, 0], self.esds[:, 1])])**0.5)
            else:
                return na

        elif self.form == 'none':
            return na


def harmcomp(data, id, q):
    """Component of modulation vector in harmonic

    Parameters
    ----------
    data : dict
        generated by core.parsecif()
    id : int
        _atom_site_fourier_wave_vector_seq_id
    q : int
        _cell_wave_vector_seq_id

    Returns
    -------
    int
        component of modulation vector in harmonic
    """

    if '_jana_atom_site_fourier_wave_vector_q1_coeff' in data:
        i = data['_atom_site_fourier_wave_vector_seq_id'].index(str(id))
        return int(data[
            '_jana_atom_site_fourier_wave_vector_q'+str(q)+'_coeff'
        ][i])

    else:
        from numpy.linalg import lstsq

        Q = modv(data)[0].transpose()
        Qp = modv(data, '_atom_site_fourier')[0].transpose()
        return lstsq(Q, Qp)[0].round().astype(int).transpose()[id-1][q-1]


def modv(data, prefix='_cell'):
    """Extracts modulation vectors

    Parameters
    ----------
    data : dict
        generated by core.parsecif()
    prefix : str
        '_cell' or '_atom_site_fourier'

    Returns
    -------
    tuple or None
        (modulation vectors, esds)
        as numpy arrays
    """

    if prefix+'_wave_vector_seq_id' not in data:
        return None
    else:
        from core import readesd
        from numpy import array, isin, vectorize
        from pandas import DataFrame

        readesd_v = vectorize(readesd)
        items = array([prefix+'_wave_vector_'+i for i in 'xyz'])
        table = DataFrame(
            {k: data[k] for k in items[isin(items, list(data.keys()))]},
            index=data[prefix+'_wave_vector_seq_id']
        )
        for k in items[isin(items, list(data.keys()), invert=True)]:
            table[k] = '0'

        return readesd_v(array(table[items]))


def readmodf(data, label, par):
    """Extracts modulation function

    Parameters
    ----------
    data : dict
        dict from core.parsecif()['data']
    label : str
        site label
    par : str
        x, y, z, o (occ)  # TODO u

    Returns
    -------
    Modf
        modulation function
    """

    from core import readesd
    from numpy import array, vectorize
    from pandas import DataFrame

    readesd_v = vectorize(readesd)
    modf = []

    if '_cell_modulation_dimension' not in data:
        return []

    if par in 'xyz':
        # HARMONIC
        if '_atom_site_displace_fourier_atom_site_label' in data:
            if (label, par) in list(zip(
                    data['_atom_site_displace_fourier_atom_site_label'],
                    data['_atom_site_displace_fourier_axis'])):
                for i in range(int(data['_cell_modulation_dimension'])):
                    table = DataFrame({k: data[k] for k in [
                        '_atom_site_displace_fourier_atom_site_label',
                        '_atom_site_displace_fourier_axis',
                        '_atom_site_displace_fourier_wave_vector_seq_id',
                        '_atom_site_displace_fourier_param_cos',
                        '_atom_site_displace_fourier_param_sin']})
                    table['harmcomp'] = [
                        harmcomp(
                            data, j, i+1
                        ) for j in table[
                            '_atom_site_displace_fourier_wave_vector_seq_id'
                        ].astype(int)
                    ]
                    table['harmcomp'] = table['harmcomp'].astype(str)
                    params, esds = readesd_v(
                        array(
                            table.query(
                                '(_atom_site_displace_fourier_atom_site_label'
                                ' == @label)'
                                ' & '
                                '(_atom_site_displace_fourier_axis'
                                ' == @par)'
                            )[['harmcomp',
                               '_atom_site_displace_fourier_param_cos',
                               '_atom_site_displace_fourier_param_sin']]
                        )
                    )
                    modf.append(Modf('harm', params, esds))

        # LEGENDRE
        if '_jana_atom_site_displace_legendre_atom_site_label' in data:
            if (label, par) in list(zip(
                    data['_jana_atom_site_displace_legendre_atom_site_label'],
                    data['_jana_atom_site_displace_legendre_axis'])):
                table = DataFrame({k: data[k] for k in [
                    '_jana_atom_site_displace_legendre_atom_site_label',
                    '_jana_atom_site_displace_legendre_axis',
                    '_jana_atom_site_displace_legendre_param_order',
                    '_jana_atom_site_displace_legendre_param_coeff']})
                params, esds = readesd_v(
                    array(
                        table.query(
                            '(_jana_atom_site_displace_legendre'
                            '_atom_site_label'
                            ' == @label)'
                            ' & '
                            '(_jana_atom_site_displace_legendre_axis'
                            ' == @par)'
                        )[['_jana_atom_site_displace_legendre_param_order',
                           '_jana_atom_site_displace_legendre_param_coeff']]
                    )
                )
                c, w = readmodf(data, label, 'o')[0].params
                modf.append(Modf('lege', [params, c, w], esds))

        # NO POSITIONAL MODULATION
        if modf == []:
            for i in range(int(data['_cell_modulation_dimension'])):
                modf.append(Modf('none'))

    elif par == 'o':
        # HARMONIC
        if '_atom_site_occ_fourier_atom_site_label' in data:
            if label in data['_atom_site_occ_fourier_atom_site_label']:
                for i in range(int(data['_cell_modulation_dimension'])):
                    table = DataFrame({k: data[k] for k in [
                        '_atom_site_occ_fourier_atom_site_label',
                        '_atom_site_occ_fourier_wave_vector_seq_id',
                        '_atom_site_occ_fourier_param_cos',
                        '_atom_site_occ_fourier_param_sin']})
                    table['harmcomp'] = [
                        harmcomp(
                            data, j, i+1
                        ) for j in table[
                            '_atom_site_occ_fourier_wave_vector_seq_id'
                        ].astype(int)
                    ]
                    table['harmcomp'] = table['harmcomp'].astype(str)
                    params, esds = readesd_v(
                        array(
                            table.query(
                                '_atom_site_occ_fourier_atom_site_label'
                                ' == @label'
                            )[['harmcomp',
                               '_atom_site_occ_fourier_param_cos',
                               '_atom_site_occ_fourier_param_sin']]
                        )
                    )
                    modf.append(Modf('harm', params, esds))

        # CRENEL
        if '_atom_site_occ_special_func_atom_site_label' in data:
            if label in data['_atom_site_occ_special_func_atom_site_label']:
                table = DataFrame({k: data[k] for k in [
                    '_atom_site_occ_special_func_atom_site_label',
                    '_atom_site_occ_special_func_crenel_c',
                    '_atom_site_occ_special_func_crenel_w']})
                params, esds = readesd_v(
                    array(
                        table.query(
                            '_atom_site_occ_special_func_atom_site_label'
                            ' == @label'
                        )[['_atom_site_occ_special_func_crenel_c',
                           '_atom_site_occ_special_func_crenel_w']]
                    )[0]
                )
                modf.append(Modf('cren', params, esds))

        # NO OCCUPANCY MODULATION
        if modf == []:
            for i in range(int(data['_cell_modulation_dimension'])):
                modf.append(Modf('none'))

    return modf
